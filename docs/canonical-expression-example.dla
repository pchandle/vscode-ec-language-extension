// Canonical expression sample for lexer/parser + resolver tests

// Metadata only; does not introduce bindings.
defaults: data, default, x64, aptissio

// Top-level sub without a surrounding job; lives in the outer scope.
sub /data/new/integer/default/x64(1, 10) -> OUTER_INT
sub /data/new/integer/default/x64(flow, 1, 10) -> OUTER_INT2, _
sub /data/new/integer/default/x64(flow, 1, 10)
sub /data/new/integer/default/x64(flow, 1, 10, 255)
sub /data/new/integer/default/x64(flow, 1, 10, 255) -> int1

job /example/arithmetic/string/default/x64(lhs, rhs, FLAGS) DOUBLE_SUM:

  // Parameters are in scope throughout the expression body.

  // numeric literals (signed, hex, octal, binary)
  -42 -> NEG_INT
  0x2A -> HEX_INT
  0o52 -> OCT_INT
  -0b00101010 -> BIN_INT

  // boolean literals (case-insensitive)
  true -> BOOL_TRUE
  FALSE -> BOOL_FALSE

  // string literal with escapes and line continuation
  "Hello \\\"quote\\\"\\n" \
    + " world" -> HELLO_STR

  // arithmetic, comparison, logical operators with precedence
  (lhs * 2 + rhs / 3 - 5) % 4 == 1 && !FLAGS -> CHECK_EXPR

  // def introduces a callable binding in the enclosing scope; params are local to the def.
  // An explicit target on def binds the obligation/result.
  def add_and_scale(a, b) result:
    2 * (a + b) -> result
  end

  // calls can use defs; targets after -> declare in the current scope.
  add_and_scale(NEG_INT, HEX_INT) -> DOUBLE_SUM

  // built-in functions on integers and strings
  max(NEG_INT, HEX_INT, BIN_INT) -> MAX_INT
  min(NEG_INT, HEX_INT) -> MIN_INT
  concat("a", "b", "c") -> CONCAT_STR
  len(HELLO_STR) -> HELLO_LEN
  trunc(HELLO_STR, 5) -> HELLO_TRUNC
  replace(HELLO_STR, "Hello", "Hi") -> HELLO_REPLACED
  int2str(DOUBLE_SUM) -> DOUBLE_STR
  escape(HELLO_STR) -> HELLO_ESCAPED
  pack("int32le", DOUBLE_SUM) -> PACKED_BYTES
  pad("*", HELLO_STR, 4) -> PADDED_STR
  maxlen(HELLO_STR) -> MAX_ALLOWED_LEN

  // if/else creates child scopes; shadowing across scopes is allowed.
  if CHECK_EXPR then
    "ok" -> STATUS_OUT
    DOUBLE_SUM + lhs -> lhs // shadows parameter in this branch only
  else
    "fail" -> STATUS_OUT
  end

  sub new/program/./linux-x64(site) -> prog
  sub new/program/./linux-x64(site) -> {
    $ -> check
  }

    sub check/condition(check) -> cond, yes, no

    sub check/condition(check) -> {
      $ -> cond2
    }, yes2, no2

    sub check/condition(check) -> {
      $ -> cond3
    }, {
      $ -> yes3
    }, {
      $ -> no3
    }

    sub check/condition(check) -> cond4, yes4, {
      $ -> no4
    }

    host /data/integer(_integer, minimum_value, maximum_value) -> int1
    host /data/integer/./x64(_integer, minimum_value, maximum_value) -> int2
    host /data/integer/default(_integer, minimum_value, maximum_value) -> int3
    host /data/integer/.(_integer, minimum_value, maximum_value) -> int4
    host /data/integer/./.(_integer, minimum_value, maximum_value) -> int5
    host /data/integer/default/x64(_integer, minimum_value, maximum_value) -> int6
    host integer(_integer, minimum_value, maximum_value) -> int7



    join /data/integer(_self_) -> min1, max1, _integer1
    join /data/integer/./x64(_self_) -> min2, max2, _integer2
    join /data/integer/default(_self_) -> min3, max3, _integer3
    join /data/integer/default/x64(_self_) -> min4, max4, _integer4
    join integer(_self_) -> min5, max5, _integer5


  // Braced blocks do not create a new scope; `$` is the incoming value.
  HELLO_STR -> {
    $ + "!" -> EXCLAMATION
    sub pack/bytes/constant(pack, EXCLAMATION)

  }

  // Inline call targets; `_` is ignored.
  sub /data/compare/integer(compare, int1, int2)

end
